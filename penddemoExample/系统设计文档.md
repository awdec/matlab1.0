# 一阶倒立摆控制系统设计文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 一阶倒立摆控制系统设计文档 |
| 文档版本 | 1.0 |
| 创建日期 | 2025-12-02 |
| 作者 | 系统设计团队 |
| 状态 | 已完成 |

## 目录

1. [概述](#概述)
2. [物理模型](#物理模型)
3. [数学建模](#数学建模)
4. [控制系统设计](#控制系统设计)
5. [Simulink实现](#simulink实现)
6. [动画系统设计](#动画系统设计)
7. [性能指标](#性能指标)

---

## 概述

### 项目背景

倒立摆系统是控制理论教学和研究中的经典案例，具有以下特点：

- **非线性系统**：动力学方程包含三角函数
- **不稳定系统**：竖直向上平衡点自然不稳定
- **欠驱动系统**：控制输入少于自由度数量
- **多变量耦合**：小车运动与摆杆姿态相互影响

### 设计目标

1. 建立准确的倒立摆物理模型和数学模型
2. 设计有效的控制策略实现摆杆平衡
3. 实现小车位置的精确跟踪控制
4. 提供直观的可视化展示

### 系统架构

系统采用三层架构设计：

```
┌─────────────────────────────────────┐
│          展示层                      │
│  (动画显示 + 信号监测)               │
├─────────────────────────────────────┤
│          控制层                      │
│  (PID控制器 + 状态观测器)            │
├─────────────────────────────────────┤
│          物理层                      │
│  (倒立摆动力学模型)                  │
└─────────────────────────────────────┘
```

---

## 物理模型

### 系统组成

一阶倒立摆系统包含以下部件：

| 部件 | 符号 | 说明 |
|------|------|------|
| 小车 | - | 沿水平导轨运动，质量为M |
| 摆杆 | - | 通过铰链连接在小车上，质量为m，长度为L |
| 驱动力 | F | 水平方向施加在小车上的控制力 |
| 导轨 | - | 限制小车水平运动，提供摩擦力 |

### 坐标系定义

建立笛卡尔坐标系，原点在导轨中心：

- **x轴**：水平向右为正
- **y轴**：竖直向上为正
- **角度θ**：摆杆与竖直方向的夹角，顺时针为正

### 状态变量

系统有4个状态变量：

| 变量 | 符号 | 物理含义 | 单位 |
|------|------|----------|------|
| 位置 | x | 小车相对原点的位移 | m |
| 速度 | ẋ (x_dot) | 小车运动速度 | m/s |
| 角度 | θ (theta) | 摆杆偏离竖直方向的角度 | rad |
| 角速度 | θ̇ (theta_dot) | 摆杆转动角速度 | rad/s |

状态向量：**X** = [x, ẋ, θ, θ̇]ᵀ

### 受力分析

#### 小车受力

1. 水平控制力 F（向右为正）
2. 摩擦力 -b·ẋ（与速度方向相反）
3. 摆杆对小车的反作用力（水平分量）

#### 摆杆受力

1. 重力 m·g（竖直向下）
2. 铰链约束力（包含水平和竖直分量）

### 物理参数

标准参数配置：

| 参数名称 | 符号 | 默认值 | 单位 | 备注 |
|---------|------|--------|------|------|
| 小车质量 | M | 0.5 | kg | 可调 |
| 摆杆质量 | m | 0.2 | kg | 可调 |
| 摆杆长度 | L | 0.3 | m | 到质心距离 |
| 重力加速度 | g | 9.8 | m/s² | 常量 |
| 摩擦系数 | b | 0.1 | N·s/m | 可调 |

---

## 数学建模

### 拉格朗日方程法

采用拉格朗日方程推导系统动力学方程。

#### 第一步：定义广义坐标

选取广义坐标：q = [x, θ]ᵀ

#### 第二步：计算动能

**小车动能**：
```
T_cart = (1/2) * M * ẋ²
```

**摆杆质心位置**：
```
x_p = x + L*sin(θ)
y_p = L*cos(θ)
```

**摆杆质心速度**：
```
ẋ_p = ẋ + L*θ̇*cos(θ)
ẏ_p = -L*θ̇*sin(θ)
```

**摆杆平动动能**：
```
T_pend_trans = (1/2) * m * (ẋ_p² + ẏ_p²)
             = (1/2) * m * [ẋ² + 2*L*ẋ*θ̇*cos(θ) + L²*θ̇²]
```

**摆杆转动动能**（绕质心）：
```
T_pend_rot = (1/2) * I * θ̇²
           = (1/2) * (1/3)*m*L² * θ̇²   (细杆近似)
```

**系统总动能**：
```
T = T_cart + T_pend_trans + T_pend_rot
  = (1/2)*(M+m)*ẋ² + (1/2)*m*L²*θ̇² + m*L*ẋ*θ̇*cos(θ) + (1/6)*m*L²*θ̇²
  = (1/2)*(M+m)*ẋ² + (2/3)*m*L²*θ̇² + m*L*ẋ*θ̇*cos(θ)
```

#### 第三步：计算势能

以导轨平面为零势能面：

```
V = m*g*L*cos(θ)
```

#### 第四步：建立拉格朗日函数

```
L = T - V
  = (1/2)*(M+m)*ẋ² + (2/3)*m*L²*θ̇² + m*L*ẋ*θ̇*cos(θ) - m*g*L*cos(θ)
```

#### 第五步：应用拉格朗日方程

对广义坐标x：
```
d/dt(∂L/∂ẋ) - ∂L/∂x = F - b*ẋ
```

对广义坐标θ：
```
d/dt(∂L/∂θ̇) - ∂L/∂θ = 0  (无外力矩直接作用在摆杆上)
```

#### 第六步：推导运动方程

经过计算整理，得到非线性微分方程组：

**小车运动方程**：
```
(M+m)*ẍ + b*ẋ + m*L*θ̈*cos(θ) - m*L*θ̇²*sin(θ) = F
```

**摆杆运动方程**：
```
(4/3)*m*L²*θ̈ + m*L*ẍ*cos(θ) - m*g*L*sin(θ) = 0
```

### 线性化

在平衡点附近线性化（θ ≈ 0）：

**小角度假设**：
- sin(θ) ≈ θ
- cos(θ) ≈ 1
- θ² ≈ 0（忽略高阶小量）

**线性化后的方程**：

小车方程：
```
(M+m)*ẍ + b*ẋ + m*L*θ̈ = F
```

摆杆方程：
```
(4/3)*L*θ̈ + ẍ - g*θ = 0
```

### 状态空间表示

定义状态向量：**X** = [x, ẋ, θ, θ̇]ᵀ

输入：u = F

**状态方程**：Ẋ = A·X + B·u

其中矩阵A和B由线性化方程推导得到：

```
A = [0      1              0                    0           ]
    [0    -b/M    -m*g/(M+m)              0           ]
    [0      0              0                    1           ]
    [0  b/(M*L)  (M+m)*g/(M*L)       0           ]
```

（简化形式，实际需根据具体参数计算）

```
B = [  0     ]
    [1/M     ]
    [  0     ]
    [-1/(M*L)]
```

**输出方程**：Y = C·X

通常选择位置和角度作为输出：
```
C = [1  0  0  0]
    [0  0  1  0]
```

### 可控性与可观性

**可控性判据**：
```
Controllability Matrix = [B, AB, A²B, A³B]
rank(Controllability Matrix) = 4  ✓ 完全可控
```

**可观性判据**：
```
Observability Matrix = [C; CA; CA²; CA³]
rank(Observability Matrix) = 4  ✓ 完全可观
```

---

## 控制系统设计

### 控制目标

1. **稳定性**：使摆杆保持竖直向上（θ → 0）
2. **跟踪性**：小车位置跟踪参考信号（x → x_ref）
3. **快速性**：调节时间 < 5秒
4. **平稳性**：超调量 < 25%

### 双环PID控制结构

采用级联双环控制：

```
         外环（位置控制）              内环（角度控制）
参考位置 ──→ (PID_outer) ──→ 期望角度 ──→ (PID_inner) ──→ 控制力
              ↑                             ↑
          实际位置                      实际角度
```

#### 外环：位置控制器

**目标**：使小车位置跟踪参考值

**输入**：位置误差 e_pos = x_ref - x

**输出**：期望摆杆角度 θ_ref

**控制律**：
```
θ_ref = Kp_outer * e_pos + Ki_outer * ∫e_pos dt + Kd_outer * de_pos/dt
```

**参数范围**（参考）：
- Kp_outer: 5 ~ 15
- Ki_outer: 0.1 ~ 1
- Kd_outer: 2 ~ 8

#### 内环：姿态控制器

**目标**：快速稳定摆杆角度

**输入**：角度误差 e_ang = θ_ref - θ

**输出**：控制力 F

**控制律**：
```
F = Kp_inner * e_ang + Ki_inner * ∫e_ang dt + Kd_inner * de_ang/dt
```

**参数范围**（参考）：
- Kp_inner: 20 ~ 50
- Ki_inner: 0 ~ 5
- Kd_inner: 5 ~ 15

### PID控制器实现要点

#### 积分抗饱和

防止积分项累积过大：

```matlab
if abs(output) < saturation_limit
    integral = integral + error * dt;
else
    % 达到饱和，停止积分
    integral = integral;  % 或使用条件积分
end
```

#### 微分滤波

抑制高频噪声：

```
滤波微分 = N/(s + N) * s * e(s)
```

典型滤波系数：N = 10

#### 输出限幅

保护执行器：

```matlab
if output > F_max
    output = F_max;
elseif output < F_min
    output = F_min;
end
```

典型限制：F ∈ [-50N, +50N]

### 状态观测器设计

#### Luenberger观测器

**动机**：
- 速度信号可能无法直接测量
- 传感器噪声需要滤波

**观测器方程**：
```
Ẋ̂ = A·X̂ + B·u + L·(y - ŷ)
ŷ = C·X̂
```

其中：
- X̂：估计状态
- L：观测器增益矩阵
- y：实际测量输出
- ŷ：估计输出

#### 极点配置

观测器极点应比控制器极点快2-5倍：

```
控制器极点：[-2, -2±2j, -3]
观测器极点：[-8, -8±8j, -12]  (快4倍)
```

使用MATLAB计算增益矩阵：

```matlab
% 期望观测器极点
poles_observer = [-8, -8+8j, -8-8j, -12];

% 计算观测器增益
L = place(A', C', poles_observer)';
```

---

## Simulink实现

### 模型层次结构

```
penddemo.slx (顶层模型)
├── Reference (参考信号生成)
│   └── Constant / Signal Generator
├── Controller (控制器子系统)
│   ├── PID_Outer (外环位置控制)
│   └── PID_Inner (内环姿态控制)
├── Pendulum (倒立摆动力学子系统)
│   ├── Force Input
│   ├── State Equations
│   ├── Integrators
│   └── Output Ports
├── State Estimator (状态观测器子系统)
│   ├── Observer Dynamics
│   └── Gain Matrix L
├── Animation (动画S-Function)
│   └── pendan.m
└── Scope (信号显示)
```

### 倒立摆动力学子系统

#### 输入/输出接口

**输入**：
- Port 1: 控制力 F [标量]

**输出**：
- Port 1: 小车位置 x [标量]
- Port 2: 小车速度 ẋ [标量]
- Port 3: 摆杆角度 θ [标量]
- Port 4: 摆杆角速度 θ̇ [标量]

#### 内部实现

使用积分器和代数模块实现微分方程：

```
F ──→ [方程求解] ──→ ẍ ──→ [积分器] ──→ ẋ ──→ [积分器] ──→ x
                       ↓
                      θ̈ ──→ [积分器] ──→ θ̇ ──→ [积分器] ──→ θ
                       ↑                    ↓
                       └────────────────────┘ (反馈耦合)
```

#### 掩码参数

子系统使用掩码界面，用户可配置：

| 参数 | 变量名 | 默认值 |
|------|--------|--------|
| Cart mass (kg) | M | 0.5 |
| Pendulum mass (kg) | m | 0.2 |
| Pendulum length (m) | L | 0.3 |
| Gravity (m/s²) | g | 9.8 |
| Friction (N·s/m) | b | 0.1 |

### PID控制器子系统

#### 实现方式

**选项1：使用PID Controller模块**

Simulink库中的标准PID模块：
- 自动提供抗饱和
- 可配置滤波系数
- 支持离散化

**选项2：手动搭建**

使用基本模块组合：
```
      [比例项]
误差 ──┼── [积分器] ──→ [积分项] ──┬──→ 相加 ──→ 输出
      └── [微分器] ──→ [微分项] ──┘
```

#### 参数配置

在掩码或模块对话框中设置：
```
外环：
  Kp = 10
  Ki = 0.5
  Kd = 5
  
内环：
  Kp = 30
  Ki = 2
  Kd = 10
```

### 状态观测器子系统

#### 实现结构

```matlab
% 使用State-Space模块实现
sys_observer = ss(A - L*C, [B, L], eye(4), zeros(4,2));
```

或手动搭建：

```
控制输入u ──┬──→ [B矩阵增益] ──┬──→ 相加 ──→ [积分器] ──→ 估计状态
            │                  ↑
测量输出y ──┼──→ [误差计算] ──→ [L矩阵增益]
            │       ↑
估计状态 ───┴──→ [C矩阵投影]
```

### 仿真参数设置

#### 求解器配置

推荐配置：

| 参数 | 值 | 说明 |
|------|-----|------|
| Solver type | Variable-step | 自动调整步长 |
| Solver | ode45 | Dormand-Prince方法 |
| Max step size | 0.01 | 限制最大步长 |
| Relative tolerance | 1e-3 | 相对精度 |

#### 数据记录

配置信号记录：
```matlab
% 在命令行设置
set_param('penddemo', 'SaveOutput', 'on');
set_param('penddemo', 'OutputSaveName', 'yout');
set_param('penddemo', 'SaveTime', 'on');
set_param('penddemo', 'TimeSaveName', 'tout');
```

---

## 动画系统设计

### S-Function架构

`pendan.m`实现Level-2 MATLAB S-Function。

#### 主要函数

| 函数名 | 调用时机 | 功能 |
|--------|----------|------|
| setup | 模型初始化 | 注册端口和参数 |
| mdlUpdate | 每个采样时刻 | 更新动画显示 |
| mdlTerminate | 仿真结束 | 清理资源 |
| LocalPendInit | 首次调用 | 创建图形窗口 |
| LocalPendSets | 更新时 | 计算并设置图形对象坐标 |

#### 输入向量

S-Function接收3维输入向量：
```
u(1): 参考位置
u(2): 实际小车位置
u(3): 摆杆角度
```

#### 采样时间

动画更新周期：0.1秒（10Hz）

```matlab
block.SampleTimes = [0.1 0];
```

### 图形对象设计

#### 坐标系设置

```matlab
AxesH = axes(...
    'Xlim', [-12 12],   % x轴范围
    'Ylim', [-2 10]);   % y轴范围
```

#### 小车绘制

使用surface对象表示小车：

```matlab
Cart = surface(...
    'XData', ones(2,1)*[x-2, x+2],  % 宽度4个单位
    'YData', [0 0; -2 -2],          % 高度2个单位
    'CData', 11*ones(2));
```

#### 摆杆绘制

使用surface对象表示摆杆：

```matlab
% 摆杆顶端坐标
x_top = x + 10*sin(theta);
y_top = 10*cos(theta);

Pend = surface(...
    'XData', [x_top-0.2*cos(theta), x_top+0.2*cos(theta);
              x-0.2*cos(theta), x+0.2*cos(theta)],
    'YData', [y_top+0.2*sin(theta), y_top-0.2*sin(theta);
              -0.2*sin(theta), 0.2*sin(theta)],
    'CData', 11*ones(2));
```

#### 参考标记

使用patch对象绘制倒三角：

```matlab
RefMark = patch(...
    'XData', ref + [-2, 0, 2],
    'YData', [-2, 0, -2],
    'FaceColor', 'flat');
```

### 用户交互

#### 滑块控件

```matlab
SlideControl = uicontrol(...
    'Style', 'slider',
    'Min', -9,
    'Max', 9,
    'Value', ref_initial,
    'Callback', 'pendan([],[],[],''Slider'');');
```

**回调函数**：
```matlab
function LocalSlider
    ud = get(gcbf, 'UserData');
    new_value = get(gcbo, 'Value');
    set_param(ud.RefBlock, 'Value', num2str(new_value));
end
```

#### 回放按钮

```matlab
uicontrol(...
    'Style', 'pushbutton',
    'String', 'Playback',
    'Callback', 'pendan([],[],[],''Playback'');',
    'Enable', 'off');  % 仿真期间禁用
```

**回放逻辑**：
```matlab
function LocalPlayback
    t = evalin('base', 't');
    y = evalin('base', 'y');
    
    for i = 1:length(t)
        LocalPendSets(t(i), ud, y(i,:));
    end
end
```

---

## 性能指标

### 时域性能指标

| 指标名称 | 符号 | 定义 | 目标值 |
|---------|------|------|--------|
| 上升时间 | t_r | 从10%到90%稳态值的时间 | < 5秒 |
| 峰值时间 | t_p | 到达第一个峰值的时间 | < 8秒 |
| 超调量 | M_p | (峰值-稳态)/稳态×100% | < 25% |
| 调节时间 | t_s | 进入±2%误差带的时间 | < 10秒 |
| 稳态误差 | e_ss | 最终偏差 | < 0.05m |

### 稳定性指标

| 指标 | 要求 |
|------|------|
| 摆杆最大偏角 | < 20° |
| 摆杆稳态角度 | < 2° |
| 系统收敛性 | 所有状态收敛 |

### 鲁棒性指标

| 测试项 | 要求 |
|--------|------|
| 参数摄动(±20%) | 仍能稳定 |
| 传感器噪声 | 性能退化 < 30% |
| 初始角度容忍 | > 15° |

### 计算方法

#### MATLAB实现

```matlab
function metrics = calculatePerformance(t, y, target)
    % 上升时间
    idx10 = find(y >= target*0.1, 1);
    idx90 = find(y >= target*0.9, 1);
    metrics.rise_time = t(idx90) - t(idx10);
    
    % 超调量
    peak = max(y);
    metrics.overshoot = (peak - target) / target * 100;
    
    % 调节时间(2%误差带)
    tolerance = abs(target) * 0.02;
    for i = length(y):-1:1
        if abs(y(i) - target) > tolerance
            metrics.settling_time = t(i);
            break;
        end
    end
    
    % 稳态误差
    steady_state = mean(y(end-10:end));
    metrics.steady_error = abs(steady_state - target);
end
```

---

## 附录

### 附录A：符号表

| 符号 | 含义 | 单位 |
|------|------|------|
| M | 小车质量 | kg |
| m | 摆杆质量 | kg |
| L | 摆杆长度（到质心） | m |
| g | 重力加速度 | m/s² |
| b | 摩擦系数 | N·s/m |
| x | 小车位置 | m |
| θ | 摆杆角度 | rad |
| F | 控制力 | N |
| Kp, Ki, Kd | PID增益 | 各异 |

### 附录B：参考文献

1. Ogata, K. (2010). "Modern Control Engineering". Prentice Hall.
2. Franklin, G.F., Powell, J.D., Emami-Naeini, A. (2015). "Feedback Control of Dynamic Systems". Pearson.
3. MathWorks Documentation: "Inverted Pendulum: System Modeling".
4. Åström, K.J., Murray, R.M. (2008). "Feedback Systems: An Introduction for Scientists and Engineers".

### 附录C：版本历史

| 版本 | 日期 | 主要变更 |
|------|------|----------|
| 1.0 | 2025-12-02 | 初始设计文档 |

---

**审核状态**：已审核  
**批准人**：技术负责人  
**文档状态**：正式发布
